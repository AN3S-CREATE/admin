
/**
 * Core Philosophy: This ruleset enforces a strict multi-tenant data isolation model.
 * All data is sandboxed within a tenant's data tree, and a user's access is
 * strictly determined by their membership and role within that specific tenant.
 *
 * Data Structure: The entire database is structured hierarchically under the
 * `/tenants/{tenantId}` path. All application data, including user profiles,
 * configurations, and events, exists within a tenant's subcollections. This
 * structure is fundamental to enforcing tenant-based security.
 *
 * Key Security Decisions:
 * - Strict Tenant Isolation: A user can only access data within the tenant they belong to.
 *   There is no cross-tenant data access.
 * - Role-Based Access: User roles ('admin', 'ops', 'hr', 'safety', 'viewer') defined
 *   in their user profile (/tenants/{tenantId}/users/{userId}) determine write permissions.
 *   Admins have full control, other roles have content creation rights, and 'viewers' are read-only.
 * - Backend Provisioning: Tenant creation and deletion are disallowed from the client
 *   to ensure these are controlled administrative actions.
 * - No Public Enumeration: Listing tenants or all users within a tenant is
 *   restricted to prevent data leakage and enumeration attacks.
 *
 * Denormalization for Authorization: To ensure fast and secure authorization, a user's
 * permissions (their tenant ID and role) are determined by a single lookup to their
 * user document at `/tenants/{tenantId}/users/{request.auth.uid}`. All other data
 * documents contain a denormalized `tenantId` field to allow for efficient rules
 * without requiring costly cross-collection `get` calls during authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists. Used for safe updates and deletes.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Retrieves the authenticated user's profile document from within a specific tenant.
     * This is the source of truth for the user's role and tenant membership.
     */
    function getUserData(tenantId) {
      return get(/databases/$(database)/documents/tenants/$(tenantId)/users/$(request.auth.uid));
    }

    /**
     * Validates if the authenticated user is a legitimate member of the specified tenant.
     * It checks for the existence of their user profile and verifies the tenantId within it.
     * This is the primary function for enforcing tenant isolation.
     */
    function isTenantMember(tenantId) {
      let userData = getUserData(tenantId);
      return isSignedIn() && userData != null && userData.data.tenantId == tenantId;
    }

    /**
     * Validates if the user is an 'admin' within the specified tenant.
     */
    function isTenantAdmin(tenantId) {
      let userData = getUserData(tenantId);
      return isTenantMember(tenantId) && userData.data.role == 'admin';
    }

    /**
     * Validates if the user has a specific role within the tenant.
     */
    function hasRole(tenantId, role) {
      let userData = getUserData(tenantId);
      return isTenantMember(tenantId) && userData.data.role == role;
    }
    
    /**
     * Validates if the user has write permissions for the tenant.
     * This is the primary function for enforcing role-based write access.
     * 'viewer' is excluded, making it a read-only role.
     */
    function canWriteInTenant(tenantId) {
      let userData = getUserData(tenantId);
      return isTenantMember(tenantId) && userData.data.role in ['admin', 'ops', 'hr', 'safety'];
    }

    /**
     * Validates that the incoming document data contains the correct tenantId on create.
     */
    function incomingDataHasTenantId(tenantId) {
      return request.resource.data.tenantId == tenantId;
    }

    /**
     * Enforces that the tenantId field cannot be changed on update.
     */
    function tenantIdIsImmutable() {
      return request.resource.data.tenantId == resource.data.tenantId;
    }

    /**
     * Enforces that the user ID field cannot be changed on update.
     */
    function userIdIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Secures the root Tenant document.
     * @path /tenants/{tenantId}
     * @allow (get) A user who is a member of this tenant can read the tenant document.
     * @deny (list) Listing all tenants is disabled to prevent enumeration.
     * @deny (create, delete) Tenant documents can only be managed by a trusted backend process.
     * @principle Restricts access to tenant members and prevents destructive client operations.
     */
    match /tenants/{tenantId} {
      allow get: if isTenantMember(tenantId);
      allow list: if false;
      allow create: if false;
      allow update: if isTenantAdmin(tenantId) && isExistingDoc();
      allow delete: if false;

      /**
       * @description Secures User profile documents within a tenant.
       * @path /tenants/{tenantId}/users/{userId}
       * @allow (get, list) An admin can read and list all users in their tenant.
       * @allow (get) A user can read their own profile.
       * @allow (create) An admin can invite/create new users.
       * @allow (update) An admin can update any user; a user can update their own profile.
       * @principle Enforces ownership and administrative oversight for user data.
       */
      match /tenants/{tenantId}/users/{userId} {
        allow get, list: if isTenantAdmin(tenantId);
        allow get: if isOwner(userId) && isTenantMember(tenantId);
        allow create: if isTenantAdmin(tenantId) && incomingDataHasTenantId(tenantId);
        allow update: if (isTenantAdmin(tenantId) || (isOwner(userId) && isTenantMember(tenantId))) && isExistingDoc() && tenantIdIsImmutable() && userIdIsImmutable();
        allow delete: if isTenantAdmin(tenantId) && isExistingDoc();
      }

      /**
       * @description Generic rule for most data subcollections within a tenant.
       * @path /tenants/{tenantId}/{collection}/{docId}
       * @allow (read) Any member of the tenant can read data.
       * @allow (write) Only users with a role in ['admin', 'ops', 'hr', 'safety'] can write. 'viewer' is implicitly read-only.
       * @principle Enforces tenant isolation for reads and role-based access for writes.
       */
      match /{collection}/{docId} {
        allow read: if isTenantMember(tenantId);
        allow write: if canWriteInTenant(tenantId) && (isExistingDoc() ? tenantIdIsImmutable() : incomingDataHasTenantId(tenantId));
      }
    }
  }
}
